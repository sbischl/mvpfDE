---
title: "Bezuschusste TÃ¤tigkeiten"
output:
    html_document:
        fig_retina: 1
---

```{r echo=FALSE, include=FALSE}
# Run the code necessary to get a list named res to access all the results. (Returned from listifyResults(.)) Probably it makes sense to load from disk, because caluclating every time is really slow.
res <- readRDS(file="results.RData")
number_of_js_plots <- 0

format <- function(result, flipsign = FALSE) {
  if (flipsign) {
    result = - result
  }
  toString(round(result,2))
}

library(ggplot2)
library(rjson)
library(scales)
library(showtext)

# Try to load the alternative font that is used in the pdf exports.
# If this font is not installed / cannot be found, the standard one will be used
tryCatch({
  plot_font <<- "Calibri"
  font_add(plot_font, "OpenSans-Regular.ttf")
}, error = function(e) {
  warning("Font is not installed. Plots are going to use the standard font instead.")
  plot_font <<- "sans"
})
showtext_auto()

makePlot <- function(program, type, heading = "", js = T) {
  if (missing(program) || missing(type)) {
    print("Need to specify program and type")
    return(0)
  }

  label <- switch(type, "wtp" = "Zahlungsbereitschaft", "cost" = "Fiskalische Kosten")
  variable <- switch(type, "wtp" = "willingness_to_pay", "cost" = "government_net_costs")

  if (js == TRUE) {
    if (number_of_js_plots > 0) {
      return(htmltools::HTML(sprintf(r"(<canvas id="chart%s" style="width: 100%%; height: %ipx"></canvas>
      <script>
      async function drawGraphs() {
        while(true) {
          if (content_loaded) {
            break;
          }
          else {
            await new Promise(r => setTimeout(r, 200));
          }
        }
        drawChart(unmodified_dataset, "%s", "%s", "%s");
      }
      drawGraphs();
      </script>
      )", paste0(program,variable), 170, variable, program, heading)))
    }

    # We have to split this in multiple strings because sprintf cannot print into strings longer than 8000 characters..
    variable_decs <- sprintf(r"(<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.3.0/chart.min.js"></script>
  <canvas id="chart%s" style="width: 100%%; height: %ipx"></canvas>
  <script>
    var unmodified_dataset;
    var document_root = "";
    var content_loaded = false;
    var additional_program_info;
    var categories;
    var colors;
    var variable_mapping;
    var tooltip_counter = 1;
    )", paste0(program,variable), 170)

    functions <- r"(async function loadJSON(url) {
    var json;
    await fetch(url).then(response => {
        json = response.json();
    });
    return json;
    }

    async function readjson(assumption_string) {
    // depends on additional_program_info being loaded as we need some way of determining which government policies exist before this function can be called

    // This will be the array carrying the data. It should be compatible to the array returned from readcsv with the only difference that the json format omits all the keys with NA values.
    var json_as_array;

    // First we need to get a list of all programs. Where the entries are strings
    var programs = additional_program_info.map(program => {
        return program.program_identifier;
    });

    // Individual json requests to all of the programs
    var requests = programs.map(program => {
        // Note: usually one would expect that this code runs the loadJSON and stores the
        // result in requests. This is not what we want, as the http requests should be
        // run in parallel for better performance. Fortunately, this is not what is happening. loadJSON is a async function. And async functions return promises. which are not automatically resolved.
        return loadJSON(document_root + "data/" + program + "/" + assumption_string + ".json");
    });

    // Resolve promises in parallel
    await Promise.all(requests).then((result) => json_as_array = result);

    // This loop merges the loaded ddata with the details about each reform (description, sources, age etc..) form programs.json. The resulting array of objects then contains all relevant data.

    for (var i = 0; i < json_as_array.length; i++) {
        Object.assign(json_as_array[i], additional_program_info[i]);
        // Rename program identifier to program. (For compatibility with the old solution)
        json_as_array[i]["program"] = json_as_array[i]["program_identifier"];
        delete json_as_array[i]["program_identifier"];
    }

    unmodified_dataset = JSON.parse(JSON.stringify(json_as_array));

    // sort by category & ensure that categories is defined already
    if (typeof(categories) != "undefined") {
        unmodified_dataset.sort(function(a, b){
            return categories.indexOf(a.category) - categories.indexOf(b.category);
        });
    }
    return json_as_array;
}

function getScalesMinMax(program) {
    // we want the same scale on all of the bar plots. To ensure this we calculate the required min length of the x-axis for each plot and apply the largest to all.
    let relevant_datapoint = unmodified_dataset.find(function (datapoint) {
        return (datapoint.program === program);
    });

    let max = addAllPositivesSubtractAllNegatives([
        Math.abs(parseFloat(relevant_datapoint["willingness_to_pay"]),
            -Math.abs(parseFloat(relevant_datapoint["government_net_costs"])))
    ]);
    let mappingEntry;

    for (let i = 0; i < variable_mapping.length; i++) {
        if (variable_mapping[i].program === program) {
            mappingEntry = variable_mapping[i];
            break;
        }
    }

    barComponents = mappingEntry["willingness_to_pay"];
    let array = [];
    let component;
    for (component in barComponents) {
        array.push(parseFloat(relevant_datapoint[component]));
    }
    max = Math.max(addAllPositivesSubtractAllNegatives(array), max);


    barComponents = mappingEntry["government_net_costs"];
    array = [];
    for (component in barComponents) {
        array.push(parseFloat(relevant_datapoint[component]));
    }
    max = Math.max(addAllPositivesSubtractAllNegatives(array), max);

    return (max);
}

function selectColor(number, background = false) {
    // returns a string in the format rgba(123,123,123,0.6)
    let background_opa = 0.7
    let foreground_opa = 0.9
    if (number > colors.length) {
        console.log("Color not in range of supplied colors in colors.json");
        // Reuse last color in this case
        number = colors.length;
    }
    color_triple = colors[number - 1];
    return `rgba(${color_triple[0]},${color_triple[1]},${color_triple[2]},${background ? background_opa : foreground_opa})`;
}

function addAllPositivesSubtractAllNegatives(array) {
    let negative = 0;
    let positive = 0;
    let i;
    for (i = 0; i < array.length; i++) {
        if (array[i] > 0) {
            positive += array[i];
        }
        else {
            negative -= array[i];
        }
    }
    return (Math.max(Math.abs(positive), Math.abs(negative)));
}

function generateBarData(csv_as_array, variable_to_plot, program) {
    let datasets = [];
    let barComponents;
    let bar_counter = 1;
    let relevant_datapoint = unmodified_dataset.find(function (datapoint) {
        return (datapoint.program === program);
    });
    if (variable_to_plot === "mvpf") {
        datasets.push({
            label: "Government Net Cost",
            data: [parseFloat(relevant_datapoint["government_net_costs"])],
            backgroundColor: selectColor(bar_counter, true),
            borderColor: selectColor(bar_counter),
        });
        datasets.push({
            label: "Willingness to Pay",
            data: [relevant_datapoint["willingness_to_pay"]],
            backgroundColor: selectColor(bar_counter + 1, true),
            borderColor: selectColor(bar_counter + 1),
        });
        bar_counter += 2;
        return (datasets);
    }
    for (let i = 0; i < variable_mapping.length; i++) {
        if (variable_mapping[i].program === program) {
            barComponents = variable_mapping[i][variable_to_plot];
            break;
        }
    }
    for (component in barComponents) {
        datasets.push({
            label: barComponents[component],
            data: [relevant_datapoint[component]],
            backgroundColor: selectColor(bar_counter, true),
            borderColor: selectColor(bar_counter)
        });
        bar_counter++;
    }
    bar_counter = 1;
    return (datasets);
}
)"
    drawChart <- r"(function drawChart(csv_as_array, variable_to_plot, program, heading = "") {
    let chartElement = document.getElementById('chart' + program + variable_to_plot);
    // Get Plotting range
    let range = getScalesMinMax(program);
    let chart = new Chart(chartElement, {
        type: 'bar',
        data: {
            labels: '.', // In ChartJS Beta 3.0 this could be left empty. If we leave it empty in 3.3, there is no graph drawn anymore. (And the tooltip is now shared for all areas of the chart in 3.3).
            datasets: generateBarData(csv_as_array, variable_to_plot, program)
        },
        options: {
            indexAxis: 'y',
            responsive: false,
            maintainAspectRatio: false,
            aspectRatio: 4,
            //devicePixelRatio: 4, //Set this to save a high res png. Otherwise leave default
            plugins: {
                title: {
                    display: true,
                    text: heading,
                    align: "start",
                    position: "top"
                },
                legend: {
                    position: 'bottom',
                    usePointStyle: true,
                    onClick: () => {} //This disables the ability to click on the legend and remove effects.
                },
                tooltip: {
                    enabled: true,
                    displayColors: false,
                    bodyColor: "black",
                    backgroundColor: "white",
                    borderWidth: 2,
                    cornerRadius: 8,
                    bodyFont: {weight: 600},
                    borderColor: "#2b6ebe",
                    mode: 'nearest',
                    callbacks: {
                        title: function (data) {
                            return null;
                        }
                    }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        maxTicksLimit: 3
                    },
                    grid: {
                        drawOnChartArea: false,
                        lineWidth: 0,
                        tickWidth: 1
                    },
                    min: -range,
                    max: range,
                    afterTickToLabelConversion: function(data) {
                        // this adds â¬ signs to the tick marks on the x-axis.
                        let ticks = data.ticks;
                        for (var i = 0; i < ticks.length; i++) {
                            ticks[i].label = ticks[i].label.replace(".", "placeholder").replace(",", ".").replace("placeholder", ",") + "â¬";
                        }
                        return data;
                    }
                },
                y: {
                    stacked: true,
                    display: false
                }
            }
        }
    });
})"
    js_exec <- sprintf(r"(if (true) {
        // load the dataset:
        Promise.all([
        loadJSON(document_root + "data/programs.json"),
        loadJSON(document_root + "data/categories.json")
    ]).then(return_values => {
        additional_program_info = return_values[0];
        categories = return_values[1];
        return Promise.all([
            readjson("default"),
            loadJSON(document_root + "data/variable_mapping.json"),
            loadJSON(document_root + "data/colors.json")
        ]);
    }).then((return_values) => {
        variable_mapping = return_values[1];
        colors = return_values[2];
        drawChart(return_values[0], "%s", "%s", "%s");
        content_loaded = true;
    });
}
</script>)",variable, program, heading)
    number_of_js_plots <<- number_of_js_plots + 1
    return(htmltools::HTML(paste0(variable_decs, functions, drawChart, js_exec)))
  }


  variable_mapping = rjson::fromJSON(file = "variable_mapping.json")

  # Construct the dataset
  for (i in 1:length(variable_mapping)) {
    if (variable_mapping[[i]]$program == program) {
      relevant_data <- variable_mapping[[i]]
    }
  }

  colors <- c(rgb(46,139,87, maxColorValue = 255),
              rgb(30,144,255, maxColorValue = 255),
              rgb(255,165,0, maxColorValue = 255),
              rgb(220,20,60, maxColorValue = 255),
              rgb(0,128,128, maxColorValue = 255),
              rgb(0,0,139, maxColorValue = 255),
              rgb(255,20,147, maxColorValue = 255),
              rgb(165,42,42, maxColorValue = 255),
              rgb(154,205,50, maxColorValue = 255),
              rgb(196, 196, 126, maxColorValue = 255),
              rgb(189,189,189, maxColorValue = 255))

  getValue <- function(name) {
    return(res[[program]][[name]])
  }
  getRange <- function(data) {
    positives = 0
    negatives = 0
    for (i in 1:length(data$values)) {
      if (data$values[[i]] >= 0) {
        positives = positives + data$values[[i]]
      }
      else {
        negatives = negatives - data$values[[i]]
      }
    }
    return(max(c(positives, negatives)))
  }

  data <- data.frame(values = sapply(names(relevant_data[[variable]]), getValue),
                     labels = unlist(relevant_data[[variable]], use.names=FALSE), x = 0)

  plot <- ggplot(data) + geom_col(aes(y = values, x = x, fill = labels)) +
    coord_flip() + theme(legend.position = "bottom") +
    scale_y_continuous(labels = function(x) paste0(x, "â¬"), limits = c(-getRange(data), getRange(data))) +
    scale_fill_manual(values = colors) +
    scale_shape_manual(values = 21) +
    ylab(label) +
    guides(fill=guide_legend(ncol=3,byrow=TRUE)) +
    theme_minimal(base_size=20,  base_family=plot_font) %+replace%
      theme (
      # axis.line.x|y control whether the x and y axis are drawn. It can look stylish to omit one or both:
      # axis.line.y = element_blank() to omit
      # e.g: axis.line.x = element_line(color = "darkgrey", size = 0.5) to draw
      axis.line.y = element_blank(),
      axis.line.x = element_line(color = "darkgrey", size = 0.75),
      axis.title.y=element_blank(),
      panel.border = element_blank(),
      panel.grid.minor = element_blank(),
      panel.grid.major = element_blank(),
      # Enable or Disable Axis ticks:
      axis.ticks = element_line(color = "darkgrey", size = 0.75),
      axis.ticks.y = element_blank(),
      # Removes Legend Explanation:
      legend.title=element_blank(),
      # Set location of legend:
      legend.position = "bottom",
      # Legend font size
      legend.text = element_text(size=10.5),
      # Axis (ticks) size
      axis.text = element_text(size=11.5),
      axis.text.y = element_blank(),
      # Axis label size
      axis.title = element_text(size=14),
      # Change Legend Stacking to vertical:
      legend.box="vertical"
      )
  print(plot)
}

```
## ArbeitsbeschaffungsmaÃnahmen
ArbeitsbeschaffungsmaÃnahmen waren ein Element der aktiven Arbeitsmarktpolitik, das Arbeitssuchenden die MÃ¶glichkeit gab eine temporÃ¤re, meist auf 12 Monate befristete TÃ¤tigkeiten auszuÃ¼ben, um die Chancen auf Wiedereingliederung in den Arbeitsmarkt zu verbessern. Die im Rahmen von ArbeitsbeschaffungsmaÃnahmen bereitgestellten Jobs sollten im "Ã¶ffentlichen Interesse" sein und keine Konkurrenz zu regulÃ¤ren Jobs darstellen. Es war daher erforderlich, dass Personen die im Rahmen einer ArbeitsbeschaffungsmaÃnahme eingestellt sind nur Aufgaben erfÃ¼llen, die sonst nicht oder zu einem spÃ¤teren Zeitpunkt erfÃ¼llt worden wÃ¤ren. Der Arbeitgeber, welcher die Arbeitsgelegenheit bereitstelle, erhielt eine Subvention zwischen 900 und 1300 Euro je nach der formalen Qualifikationen der eingestellten Person. AbhÃ¤ngig von lokalen Gegebenheiten konnte die Subvention auch hÃ¶her ausfallen. Es gab jedoch die EinschrÃ¤nkung, dass die Subvention den gezahlten Lohn nicht Ã¼berschreiten durfte. Seit 2012 werden keine neuen BeschÃ¤ftigungsverhÃ¤ltnisse mehr subventioniert.
 Hohmeyer & Wolff (2010), evaluieren die EffektivitÃ¤t von subventionierten TÃ¤tigkeiten anhand von administrativen Daten. Die Autoren nutzen einen Propensity Score Matching Ansatz, um die Auswirkungen der Teilnahme an subventionierten BeschÃ¤ftigungsprogrammen zu ermitteln. Hohmeyer & Wolff (2010) geben den Effekt der Anstellung im Rahmen einer ArbeitsbeschaffungsmaÃnahme auf das Bruttoeinkommen und die Arbeitslosengeld II Zahlungen in den drei darauffolgenden Jahren an. Die EffektstÃ¤rke wird separat fÃ¼r MÃ¤nner und Frauen in Ost- und Westdeutschland angegeben. Zur Berechnung des MVPFs wird der gewichtete Durchschnitt gemÃ¤Ã dem Anteil der jeweiligen Subpopulation im Datensatz von Hohmeyer & Wolff (2010) gebildet. Die BeschÃ¤ftigung im Rahmen einer ArbeitsbeschaffungsmaÃnahme ist im Durchschnitt mit einem positiven Effekt auf das Einkommen von 4444,18â¬ im ersten Jahr, 1167,21â¬ im zweiten Jahr und 474,51â¬ im dritten Jahr assoziiert. Der Bezug von Leistungen des Arbeitslosengeld II ging um jeweils 2902,86â¬, 157,58â¬ und 120,77â¬ zurÃ¼ck. Eine Simulation des deutschen Steuersystems wird angewendet, um das verbleibende Nettoeinkommen und die Steuerzahlungen zu berechnen. Hierbei werden BeitrÃ¤ge zur Kranken- und Pflegeversicherung als Steuer interpretiert. Die mit einer Diskontrate von 3% abgezinste Summe der NettoeinkommensÃ¤nderungen betrÃ¤gt `r format(res$jobCreationSchemes$net_income_increase)`â¬. Dies entspricht der Zahlungsbereitschaft fÃ¼r die Teilnahme an einer ArbeitsbeschaffungsmaÃnahme.

 Die Nettokosten von ArbeitsbeschaffungsmaÃnahmen setzen sich aus 3 Komponenten zusammen: (i) Dem Barwert der Ãnderungen des Steueraufkommens (`r format(res$jobCreationSchemes$tax_revenue_increase, T)`â¬), (ii) dem Barwert des Effekts auf den Bezug von Leistungen des Arbeitslosengeld II (2902,86â¬ + 157,58â¬ / 1.03 + 120,77â¬ * (1/1,03)Â² = `r format(res$jobCreationSchemes$benefit_receipt, T)`â¬) und (iii) den von Arbeitsagentur getragenen Kosten fÃ¼r die ArbeitsbeschaffungsmaÃnahme. Hohmeyer & Wolff (2010) geben durchschnittliche monatliche Kosten in HÃ¶he von 1240,50â¬ in den Jahren 2005 und 2006 an.  Bei einer BeschÃ¤ftigungsdauer von 12 Monaten resultieren Gesamtkosten fÃ¼r die Bereitstellung der subventionierten Bereitstellung von 12 â 1240,50â¬ = 14886â¬. Die Nettokosten der ArbeitsbeschaffungsmaÃnahmen betragen -`r format(res$jobCreationSchemes$tax_revenue_increase, T)`â¬ - `r format(res$jobCreationSchemes$benefit_receipt, T)`â¬ + `r format(res$jobCreationSchemes$program_cost)`â¬ = `r format(res$jobCreationSchemes$government_net_costs)`â¬
 ```{r echo = FALSE, fig.align = 'center', fig.width = 8, fig.height = 2.4, fig.showtext=TRUE}
makePlot("jobCreationSchemes", "cost", "Kostenkomposition ArbeitsbeschaffungsmaÃnahmen")
```
Es ergibt sich ein MVPF von  `r format(res$jobCreationSchemes$net_income_increase)`â¬ / `r format(res$jobCreationSchemes$government_net_costs)`â¬ =  `r format(res$jobCreationSchemes$mvpf)`. Pro Euro Steuergeld, der in die Bereitstellung von ArbeitsbeschaffungsmaÃnahmen investiert wird, erhalten gefÃ¶rderte Arbeitnehmer einen Wert von `r format(res$jobCreationSchemes$mvpf)` Euro.

## Ein-Euro-Jobs
Ein-Euro-Jobs, formal Arbeitsgelegenheiten mit MehraufwandsentschÃ¤digung, sind ArbeitsplÃ¤tze, die Langzeitarbeitslosen vermittelt werden, um sie bei der Wiedereingliederung in den Arbeitsmarkt zu unterstÃ¼tzen. Diese Jobs sind als unbezahlte Arbeit gedacht. Die Teilnehmer erhalten jedoch eine MehraufwandsentschÃ¤digung von mindestens einem Euro pro Arbeitsstunde. Ein-Euro-Jobs sind grundsÃ¤tzlich Ã¤hnlich zu den seit 2012 abgeschafften ArbeitsbeschaffungsmaÃnahmen. Auch fÃ¼r Ein-Euro-Jobs gilt, dass die ausgeÃ¼bten TÃ¤tigkeiten nicht in Konkurrenz zu einem regulÃ¤ren Job stehen darf. Es sollen daher lediglich zusÃ¤tzliche Aufgaben, die sonst nicht erfÃ¼llt wÃ¼rden, durch Ein-Euro-Jobber erfÃ¼llt werden. Arbeitgeber die Ein-Euro-Jobs bereitstellen, erhalten eine Subvention von der Arbeitsagentur um zusÃ¤tzliche Kosten abzudecken. Die Dauer der BeschÃ¤ftigung ist in der Regel auf sechs bis sieben Monate begrenzt. Personen die einen zugewiesen Ein-Euro-Job ohne triftigen Grund ablehnen kÃ¶nnen sanktioniert werden. In der Regel bedeutet dies eine KÃ¼rzung des Arbeitslosengeldes II.
Hohmeyer & Wolff (2010), evaluieren die EffektivitÃ¤t von subventionierten TÃ¤tigkeiten anhand von administrativen Daten. Die Autoren nutzen einen Propensity Score Matching Ansatz, um die Auswirkungen der Teilnahme an subventionierten BeschÃ¤ftigungsprogrammen zu ermitteln. Hohmeyer & Wolff (2010) geben den Effekt der Anstellung im Rahmen eines Ein-Euro-Jobs auf das Bruttoeinkommen und die Arbeitslosengeld II Zahlungen in den drei darauffolgenden Jahren an. Die EffektstÃ¤rke wird separat fÃ¼r MÃ¤nner und Frauen in Ost- und Westdeutschland angegeben. Zur Berechnung des MVPFs wird der gewichtete Durchschnitt gemÃ¤Ã dem Anteil der jeweiligen Subpopulation im Datensatz von Hohmeyer & Wolff (2010) gebildet. Die Aufnahme eines Ein-Euro-Jobs ist im Durchschnitt mit einem negativen Effekt auf das Einkommen von 287,12â¬ im ersten Jahr und 83,35â¬ im zweiten Jahr assoziiert. Im dritten Jahr nach Beginn des Ein-Euro-Jobs, das heiÃt circa zweieinhalb Jahre nach Abschluss des Ein-Euro-Jobs, wird ein Effekt leicht positiv (87,27â¬). Der Bezug von Leistungen des Arbeitslosengeld II nahm um jeweils 378,47â¬, 216,02â¬ und 180,02â¬ zu. Eine Simulation des deutschen Steuersystems wird angewendet, um die Auswirkung auf das Nettoeinkommen und die Steuerzahlungen zu berechnen. Hierbei werden BeitrÃ¤ge zur Kranken- und Pflegeversicherung als Steuer interpretiert. Die mit einer Diskontrate von 3% abgezinste Summe der NettoeinkommensÃ¤nderungen betrÃ¤gt -`r format(res$oneEuroJobs$net_income_increase)`â¬. Dieser negative Wert entspricht zugleich der Zahlungsbereitschaft fÃ¼r die Aufnahme eines Ein-Euro-Jobs.

 Die Nettokosten von ArbeitsbeschaffungsmaÃnahmen setzen sich aus 3 Komponenten zusammen: (i) Dem Barwert der RÃ¼ckgang des Steueraufkommens (`r format(res$oneEuroJobs$tax_revenue_increase)`â¬), (ii) dem Barwert des Effekts auf den Bezug von Leistungen des Arbeitslosengeld II (378,47â¬ + 216,02â¬ / 1.03 + 180,02â¬  * (1/1,03)Â² = `r format(res$oneEuroJobs$benefit_receipt)`â¬) und (iii) den von Arbeitsagentur getragenen Kosten fÃ¼r die ArbeitsbeschaffungsmaÃnahme. Hohmeyer & Wolff (2010) geben durchschnittliche monatliche Kosten in HÃ¶he von 361,50â¬ in den Jahren 2005 und 2006 an.  Bei einer BeschÃ¤ftigungsdauer von 7 Monaten fallen Gesamtkosten fÃ¼r die Bereitstellung der subventionierten Bereitstellung von 7 â 361,50â¬ = 2530,50â¬ an. Die Nettokosten der ArbeitsbeschaffungsmaÃnahmen betragen `r format(res$oneEuroJobs$tax_revenue_increase)`â¬ + `r format(res$oneEuroJobs$benefit_receipt)`â¬ + `r format(res$oneEuroJobs$program_cost)`â¬ = `r format(res$oneEuroJobs$government_net_costs)`â¬
 ```{r echo = FALSE, fig.align = 'center', fig.width = 8, fig.height = 2.4, fig.showtext=TRUE}
makePlot("oneEuroJobs", "cost", "Kostenkomposition Ein-Euro-Jobs")
```
Es ergibt sich ein MVPF von  `r format(res$oneEuroJobs$net_income_increase)`â¬ / `r format(res$oneEuroJobs$government_net_costs)`â¬ =  `r format(res$oneEuroJobs$mvpf)`. Pro Euro Steuergeld, der in die Bereitstellung von Ein-Euro-Jobs investiert wird, erhalten gefÃ¶rderte Arbeitnehmer einen Wert von `r format(res$oneEuroJobs$mvpf)` Euro.

## Arbeitsgelegenheiten
Arbeitsgelegenheiten, formal Arbeitsgelegenheiten in der Entgeltvariante, stellen neben den Ein-Euro-Jobs eine weitere von der Arbeitsagentur subventionierte und    befristete BeschÃ¤ftigungsmÃ¶glichkeit dar. Insgesamt legen die Arbeitsgelegenheiten einen stÃ¤rkeren Fokus auf Reintegration in den Arbeitsmarkt. WÃ¤hrend Ein-Euro-Jobs gemeinnÃ¼tzig und zusÃ¤tzlich sein mÃ¼ssen, kÃ¶nnen im Rahmen von Arbeitsgelegenheiten regulÃ¤re Jobs gefÃ¶rdert werden. Arbeitgeber erhalten eine Subvention um Mehrkosten zu kompensieren, die durch die Bereitstellung der Arbeitsgelegenheit entstehen. Die gefÃ¶rderte Arbeitnehmer sollen einen normalen Lohn erhalten. Etwaige ProduktivitÃ¤tsunterschiede kÃ¶nnen durch die Subvention ausgeglichen werden. Die HÃ¶he der Subvention ist nicht gedeckelt. Die Dauer der FÃ¶rderung ist in der Praxis auf 12 Monate begrenzt.
Hohmeyer & Wolff (2010), evaluieren die EffektivitÃ¤t von subventionierten TÃ¤tigkeiten anhand von administrativen Daten. Die Autoren nutzen einen Propensity Score Matching Ansatz, um die Auswirkungen der Teilnahme an subventionierten BeschÃ¤ftigungsprogrammen zu ermitteln. Hohmeyer & Wolff (2010) geben den Effekt der Anstellung im Rahmen einer Arbeitsgelegenheit auf das Bruttoeinkommen und die Arbeitslosengeld II Zahlungen in den drei darauffolgenden Jahren an. Die EffektstÃ¤rke wird separat fÃ¼r MÃ¤nner und Frauen in Ost- und Westdeutschland angegeben. Zur Berechnung des MVPFs wird der gewichtete Durchschnitt gemÃ¤Ã dem Anteil der jeweiligen Subpopulation im Datensatz von Hohmeyer & Wolff (2010) gebildet. Die BeschÃ¤ftigung im Rahmen einer Arbeitsgelegenheit ist im Durchschnitt mit einem positiven Effekt auf das Einkommen von 4305,80â¬ im ersten Jahr, 1526,05â¬ im zweiten Jahr und 1118,48â¬ im dritten Jahr assoziiert. Der Bezug von Leistungen des Arbeitslosengeld II ging um jeweils 2886,91â¬, 451,30â¬ und 369,37â¬ zurÃ¼ck. Eine Simulation des deutschen Steuersystems wird angewendet, um das verbleibende Nettoeinkommen und die Steuerzahlungen zu berechnen. Hierbei werden BeitrÃ¤ge zur Kranken- und Pflegeversicherung als Steuer interpretiert. Die mit einer Diskontrate von 3% abgezinste Summe der NettoeinkommensÃ¤nderungen betrÃ¤gt `r format(res$subsidizedJobOpportunities$net_income_increase)`â¬. Dies entspricht der Zahlungsbereitschaft fÃ¼r die AusÃ¼bung der subventionierten TÃ¤tigkeit.

 Die Nettokosten von ArbeitsbeschaffungsmaÃnahmen setzen sich aus 3 Komponenten zusammen: (i) Dem Barwert der Ãnderungen des Steueraufkommens (`r format(res$subsidizedJobOpportunities$tax_revenue_increase, T)`â¬), (ii) dem Barwert des Effekts auf den Bezug von Leistungen des Arbeitslosengeld II (2886,91â¬ + 451,30â¬ / 1.03 + 369,37â¬ * (1/1,03)Â² = `r format(res$subsidizedJobOpportunities$benefit_receipt, T)`â¬) und (iii) den von Arbeitsagentur getragenen Kosten fÃ¼r die Arbeitsgelegenheit. Hohmeyer & Wolff (2010) geben durchschnittliche monatliche Kosten in HÃ¶he von 1742,50â¬ in den Jahren 2005 und 2006 an. Bei einer BeschÃ¤ftigungsdauer von 12 Monaten resultieren Gesamtkosten fÃ¼r die Bereitstellung der subventionierten Bereitstellung von 12 â 1742,50â¬ = 20910â¬. Die Nettokosten der Arbeitsgelegenheiten betragen -`r format(res$subsidizedJobOpportunities$tax_revenue_increase, T)`â¬ - `r format(res$subsidizedJobOpportunities$benefit_receipt, T)`â¬ + `r format(res$subsidizedJobOpportunities$program_cost)`â¬ = `r format(res$subsidizedJobOpportunities$government_net_costs)`â¬
 ```{r echo = FALSE, fig.align = 'center', fig.width = 8, fig.height = 2.4, fig.showtext=TRUE}
makePlot("subsidizedJobOpportunities", "cost", "Kostenkomposition Arbeitsgelegenheiten")
```
Es ergibt sich ein MVPF von  `r format(res$subsidizedJobOpportunities$net_income_increase)`â¬ / `r format(res$subsidizedJobOpportunities$government_net_costs)`â¬ =  `r format(res$subsidizedJobOpportunities$mvpf)`. Pro Euro Steuergeld, der in die Bereitstellung von Arbeitsgelegenheiten investiert wird, erhalten gefÃ¶rderte Arbeitnehmer einen Wert von `r format(res$subsidizedJobOpportunities$mvpf)` Euro. Verglichen mit Ein-Euro-Jobs sind Arbeitsgelegenheiten deutlich teurer. Die monatlichen Subventionskosten sind fast 4 mal hÃ¶her. Im Gegensatz zu den Ein-Euro-Jobs kÃ¶nnen die Arbeitsgelegenheiten die erzielten Einkommen jedoch etwas steigern.